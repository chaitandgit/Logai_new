# --------------------------------------------------------
# 4b. Template-aware burst & sequence anomalies
# --------------------------------------------------------

# --- Burst detection ---
# Count how many times each template appears in a sliding window
df = df.sort_values("@timestamp")  # ensure time order
window_size = "5min"  # adjust as needed

# Rolling counts per template
df["burst_count"] = (
    df.set_index(pd.to_datetime(df["@timestamp"]))
      .groupby("features.tpl_hash")["features.tpl_hash"]
      .transform(lambda x: x.rolling(window=window_size).count())
)

# Burst flag: template count higher than its mean + 3Ïƒ (per template)
template_stats = df.groupby("features.tpl_hash")["burst_count"].agg(["mean", "std"]).reset_index()
template_stats["threshold"] = template_stats["mean"] + 3 * template_stats["std"]
df = df.merge(template_stats[["features.tpl_hash", "threshold"]], on="features.tpl_hash", how="left")
df["burst_flag"] = (df["burst_count"] > df["threshold"]).astype(int)


# --- Sequence mismatch detection ---
# Encode template IDs numerically
tpl_ids = df["features.tpl_hash"].astype("category").cat.codes
df["tpl_id"] = tpl_ids

# Build bigrams of (prev, current)
df["tpl_prev"] = df["tpl_id"].shift(1)
df["tpl_bigram"] = df["tpl_prev"].astype(str) + "->" + df["tpl_id"].astype(str)

# Learn frequent transitions (bigrams)
bigram_counts = df["tpl_bigram"].value_counts()
valid_bigrams = set(bigram_counts[bigram_counts > 5].index)  # keep only frequent ones

# Sequence flag: 1 if bigram not seen often before
df["sequence_flag"] = (~df["tpl_bigram"].isin(valid_bigrams)).astype(int)