# --------------------------------------------------------
# 4b. Burst & sequence anomalies
# --------------------------------------------------------
# Robust datetime parsing (force UTC to avoid tz mix issues)
df["@timestamp"] = pd.to_datetime(df["@timestamp"], errors="coerce", utc=True)
df = df.sort_values("@timestamp").set_index(df["@timestamp"])
window_size = "5min"

# Burst count per template
df["burst_count"] = (
    df.groupby("features.tpl_hash")["features.tpl_hash"]
      .transform(lambda x: x.rolling(window=window_size).count())
)

# Burst flag (μ+3σ rule)
template_stats = df.groupby("features.tpl_hash")["burst_count"].agg(["mean", "std"]).reset_index()
template_stats["threshold"] = template_stats["mean"] + 3 * template_stats["std"]
df = df.merge(template_stats[["features.tpl_hash", "threshold"]], on="features.tpl_hash", how="left")
df["burst_flag"] = (df["burst_count"] > df["threshold"]).astype(int)

# Sequence anomalies
df["tpl_id"] = df["features.tpl_hash"].astype("category").cat.codes
df["tpl_prev"] = df["tpl_id"].shift(1)
df["tpl_bigram"] = df["tpl_prev"].astype(str) + "->" + df["tpl_id"].astype(str)

bigram_counts = df["tpl_bigram"].value_counts()
valid_bigrams = set(bigram_counts[bigram_counts > 5].index)
df["sequence_flag"] = (~df["tpl_bigram"].isin(valid_bigrams)).astype(int)

df = df.reset_index(drop=True)